<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta content="IE=Edge" http-equiv="X-UA-Compatible" />
  <meta name="description" content="Ecency Waves" />
  <title>waves</title>
</head>

<body>
  <script src="https://unpkg.com/@hiveio/dhive@latest/dist/dhive.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@hiveio/hive-js/dist/hive.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-base64@3.7.7/base64.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
    integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://bundle.run/buffer@6.0.3"></script>
  <script>
    window.addEventListener("load", function () {
      if (window._flutter && window._flutter.loader) {
        window._flutter.loader.loadEntrypoint({
          serviceWorker: { serviceWorkerVersion: null },
          onEntrypointLoaded: function (engineInitializer) {
            engineInitializer.initializeEngine().then(function (appRunner) {
              appRunner.runApp();
            });
          },
        });
      }
    });

    const HIVE_NODES = [
      "https://api.hive.blog",
      "https://api.deathwing.me",
      "https://hive-api.arcange.eu",
      "https://rpc.mahdiyari.info",
      "https://api.openhive.network",
      "https://rpc.ausbit.dev",
      "https://techcoderx.com",
      "https://hived.emre.sh",
      "https://hive-api.3speak.tv",
      "https://anyx.io",
      "https://api.hive.blue",
      "https://api.c0ff33a.uk",
      "https://api.pharesim.me",
      "https://hived.privex.io",
      "https://hive.roelandp.nl",
    ];
    const client = new dhive.Client(HIVE_NODES);

    try {
      if (hive && hive.api && typeof hive.api.setOptions === "function") {
        hive.api.setOptions({ useAppbaseApi: true, url: HIVE_NODES[0] });
      }

      if (hive && hive.config && typeof hive.config.set === "function") {
        hive.config.set(
          "alternative_api_endpoints",
          HIVE_NODES.slice(1),
        );
      }
    } catch (configurationError) {
      console.warn("Unable to configure hive-js endpoints", configurationError);
    }

    const hasAndroid = typeof Android !== "undefined"
      && Android
      && typeof Android.postMessage === "function";
    const hasIOS = typeof window.webkit !== "undefined"
      && window.webkit
      && window.webkit.messageHandlers
      && window.webkit.messageHandlers.app
      && typeof window.webkit.messageHandlers.app.postMessage === "function";

    function replyToNative(result, id, stringifyResult = true) {
      const payload = stringifyResult && typeof result !== "string"
        ? JSON.stringify(result)
        : result;

      if (id) {
        if (hasAndroid) {
          try {
            Android.postMessage(payload, id);
          } catch (androidError) {
            console.warn("Android bridge error", androidError);
          }
        }
        if (hasIOS) {
          try {
            window.webkit.messageHandlers.app.postMessage({ id, data: payload });
          } catch (iosError) {
            console.warn("iOS bridge error", iosError);
          }
        }
      }

      return payload;
    }

    function deliver(id, payload) {
      return replyToNative(payload, id, true);
    }

    const ok = (id, data) => deliver(id, { valid: true, data, error: "" });
    const fail = (id, err) => {
      const message = (err && err.message) ? err.message : String(err);
      return deliver(id, { valid: false, data: null, error: message });
    };

    function b64ToUtf8(b64) {
      try {
        const bin = atob(b64);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i += 1) {
          bytes[i] = bin.charCodeAt(i);
        }
        return new TextDecoder("utf-8").decode(bytes);
      } catch (e) {
        try {
          return atob(b64);
        } catch (_) {
          return "";
        }
      }
    }

    function b64uEnc(str) {
      const b64uLookup = {
        "/": "_",
        _: "/",
        "+": "-",
        "-": "+",
        "=": ".",
        ".": "=",
      };
      return window.Base64.encode(str).replace(/(\+|\/|=)/g, (match) => b64uLookup[match]);
    }

    let messageObj = null;

    async function runThisJS(jsCode, id) {
      try {
        const executor = new Function(`
          "use strict";
          return (async () => { ${jsCode} })();
        `);
        const result = await executor();
        return ok(id, result);
      } catch (error) {
        return fail(id, error);
      }
    }

    function doWeHaveHiveKeychainExtension(id) {
      try {
        return ok(id, !!window.hive_keychain);
      } catch (error) {
        return fail(id, error);
      }
    }

    function signInWithHiveKeychain(id, username, message) {
      try {
        const keychain = window.hive_keychain;
        if (!keychain) {
          return fail(id, "Hive Keychain extension not found");
        }
        keychain.requestSignBuffer(username, message, "Active", (response) => {
          const valid = !!(response && response.success);
          deliver(id, {
            valid,
            data: response,
            error: valid ? "" : (response && response.error) ? response.error : "Keychain error",
          });
        });
        return "";
      } catch (error) {
        return fail(id, error);
      }
    }

    function getRedirectUriData(id, uname) {
      try {
        const username = String(uname || "").toLowerCase();
        const timestamp = Date.now() / 1000;
        messageObj = {
          signed_message: { type: "code", app: "ecency.app" },
          authors: [username],
          timestamp,
        };
        const message = JSON.stringify(messageObj);
        const authData = {
          app: {
            name: "Waves",
            description: "Ecency - Waves - Mobile App",
          },
          token: undefined,
          challenge: {
            key_type: "posting",
            challenge: message,
          },
        };
        const authKey = uuidv4();
        const encrypted = CryptoJS.AES.encrypt(
          JSON.stringify(authData),
          authKey,
        ).toString();
        return ok(id, { encrypted_data: encrypted, auth_key: authKey });
      } catch (error) {
        return fail(id, error);
      }
    }

    function getDecryptedHASToken(id, username, data, authKey) {
      try {
        const decrypted = JSON.parse(
          CryptoJS.AES.decrypt(data, authKey).toString(CryptoJS.enc.Utf8),
        );
        const token = decrypted.token;
        const expire = decrypted.expire;
        const challenge = decrypted.challenge && decrypted.challenge.challenge;
        if (!messageObj) {
          messageObj = {
            signed_message: { type: "code", app: "ecency.app" },
            authors: [String(username || "").toLowerCase()],
            timestamp: Date.now() / 1000,
          };
        }
        messageObj.signatures = [challenge];
        const hsToken = b64uEnc(JSON.stringify(messageObj));
        return ok(id, { token, expire, hsToken });
      } catch (error) {
        return fail(id, error);
      }
    }

    function resolvePrivateKey(username, rawKey, keyType) {
      if (!rawKey) {
        throw new Error("Missing key");
      }

      try {
        return dhive.PrivateKey.fromString(rawKey);
      } catch (wifError) {
        try {
          return dhive.PrivateKey.fromLogin(
            username,
            rawKey,
            keyType || "posting",
          );
        } catch (loginError) {
          const error = new Error("Invalid key supplied");
          error.cause = loginError;
          error.data = { reason: loginError.message };
          throw error;
        }
      }
    }

    function extractTransactionId(result) {
      if (!result || typeof result !== "object") {
        return null;
      }

      if (typeof result.id === "string" && result.id.length) {
        return result.id;
      }

      if (typeof result.tx_id === "string" && result.tx_id.length) {
        return result.tx_id;
      }

      if (typeof result.transaction_id === "string" && result.transaction_id.length) {
        return result.transaction_id;
      }

      if (
        result.result &&
        typeof result.result === "object" &&
        typeof result.result.id === "string" &&
        result.result.id.length
      ) {
        return result.result.id;
      }

      return null;
    }

    function normalizeBroadcastPayload(provider, result) {
      const txId = extractTransactionId(result);

      if (!txId) {
        const error = new Error("Broadcast response did not include a transaction id");
        error.data = { provider, result };
        throw error;
      }

      return { provider, txId, result };
    }

    function broadcastWithHiveJs(operations, privateKey, keyType) {
      return new Promise((resolve, reject) => {
        const authField = keyType === "active" ? "active" : "posting";
        hive.broadcast.send(
          { extensions: [], operations },
          { [authField]: privateKey },
          (error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          },
        );
      });
    }

    async function ensureKeyMatchesAccount(username, publicKey, keyType) {
      const normalizedType = keyType || "posting";
      const [account] = await client.database.getAccounts([username]);

      if (!account) {
        const error = new Error("Account not found");
        error.data = { username };
        throw error;
      }

      const authorityFields = [];

      if (normalizedType === "posting") {
        authorityFields.push(account.posting);
      }

      if (normalizedType === "active" || normalizedType === "posting") {
        authorityFields.push(account.active);
      }

      authorityFields.push(account.owner);

      const allowedKeys = new Set();
      authorityFields.forEach((authority) => {
        if (!authority || !Array.isArray(authority.key_auths)) {
          return;
        }

        authority.key_auths.forEach((entry) => {
          if (Array.isArray(entry) && typeof entry[0] === "string") {
            allowedKeys.add(entry[0]);
          }
        });
      });

      if (!allowedKeys.has(publicKey)) {
        const error = new Error(`Provided key is not authorized for ${normalizedType} operations`);
        error.data = { username, keyType: normalizedType };
        throw error;
      }
    }

    async function sendOperationsWithKey(
      username,
      rawKey,
      keyType,
      operations,
    ) {
      const normalizedType = keyType || "posting";
      const privateKey = resolvePrivateKey(username, rawKey, normalizedType);
      const publicKey = privateKey.createPublic().toString();

      await ensureKeyMatchesAccount(username, publicKey, normalizedType);

      try {
        const primaryResult = await client.broadcast.sendOperations(
          operations,
          privateKey,
        );

        return normalizeBroadcastPayload("dhive", primaryResult);
      } catch (primaryError) {
        console.warn("dhive broadcast failed, attempting hive-js", primaryError);

        const fallbackResult = await broadcastWithHiveJs(
          operations,
          privateKey.toString(),
          normalizedType,
        ).catch((fallbackError) => {
          fallbackError.cause = primaryError;
          throw fallbackError;
        });

        return normalizeBroadcastPayload("hive-js", fallbackResult);
      }
    }

    function performOperations(
      id,
      operations,
      operationName,
      username,
      key,
      token,
      authKey,
      keyType = "posting",
    ) {
      const resolvedKeyType = keyType || "posting";
      if (
        typeof token === "string" && token.length > 0 &&
        typeof authKey === "string" && authKey.length > 0
      ) {
        const signData = {
          key_type: resolvedKeyType,
          ops: operations,
          broadcast: true,
          nonce: Date.now(),
        };
        const encrypted = CryptoJS.AES.encrypt(
          JSON.stringify(signData),
          authKey,
        ).toString();
        return ok(id, encrypted);
      }

      return sendOperationsWithKey(username, key, resolvedKeyType, operations)
        .then((result) => ok(id, result))
        .catch((error) => fail(id, error));
    }

    async function commentOnContent(
      id,
      username,
      parentAuthor,
      parentPermlink,
      permlink,
      commentBase64,
      tagsInput,
      postingKey,
      token,
      authKey,
    ) {
      try {
        if (!postingKey) {
          return fail(id, "Missing postingKey");
        }

        const body = typeof commentBase64 === "string"
          ? b64ToUtf8(commentBase64)
          : String(commentBase64 || "");

        let tags = [];
        if (Array.isArray(tagsInput)) {
          tags = tagsInput;
        } else if (typeof tagsInput === "string" && tagsInput.length) {
          try {
            const parsed = JSON.parse(tagsInput);
            if (Array.isArray(parsed)) {
              tags = parsed;
            }
          } catch (_) {
            // ignore
          }
        }

        const jsonMetadata = { app: "waves", tags, format: "markdown" };

        const op = ['comment', {
          parent_author: parentAuthor,
          parent_permlink: parentPermlink,
          author: username,
          permlink,
          title: "",
          body,
          json_metadata: JSON.stringify(jsonMetadata),
        }];

        return performOperations(
          id,
          [op],
          "commentOnContent",
          username,
          postingKey,
          token,
          authKey,
        );
      } catch (error) {
        return fail(id, error);
      }
    }

    function voteContent(
      id,
      username,
      author,
      permlink,
      weight,
      postingKey,
      token,
      authKey,
    ) {
      try {
        const op = ['vote', {
          voter: username,
          author,
          permlink,
          weight: parseInt(weight, 10),
        }];

        return performOperations(
          id,
          [op],
          "voteContent",
          username,
          postingKey,
          token,
          authKey,
        );
      } catch (error) {
        return fail(id, error);
      }
    }

    function transfer(
      id,
      username,
      to,
      amount,
      asset,
      memo,
      privateKey,
      token,
      authKey,
    ) {
      try {
        if (!privateKey) {
          return fail(id, "Missing active key or master password");
        }
        if (!username) {
          return fail(id, "Missing sender username");
        }
        if (!to) {
          return fail(id, "Missing recipient");
        }
        if (!asset) {
          return fail(id, "Missing asset symbol");
        }

        const parsedAmount = Number.parseFloat(amount);
        if (!Number.isFinite(parsedAmount)) {
          return fail(id, "Invalid amount supplied");
        }

        const amountLiteral = `${parsedAmount.toFixed(3)} ${String(asset).toUpperCase()}`;

        const op = ['transfer', {
          from: username,
          to,
          amount: amountLiteral,
          memo: memo || '',
        }];

        return performOperations(
          id,
          [op],
          "transfer",
          username,
          privateKey,
          token,
          authKey,
          "active",
        );
      } catch (error) {
        return fail(id, error);
      }
    }

    function castPollVote(
      id,
      username,
      pollId,
      choices,
      postingKey,
      token,
      authKey,
    ) {
      try {
        if (!username) {
          return fail(id, "Missing username");
        }
        if (!pollId) {
          return fail(id, "Missing pollId");
        }
        if (!postingKey) {
          return fail(id, "Missing postingKey");
        }

        let normalizedChoices = [];
        if (Array.isArray(choices)) {
          normalizedChoices = choices.map((choice) => parseInt(choice, 10)).filter(Number.isFinite);
        } else if (typeof choices === "string") {
          try {
            const parsed = JSON.parse(choices);
            if (Array.isArray(parsed)) {
              normalizedChoices = parsed.map((choice) => parseInt(choice, 10)).filter(Number.isFinite);
            }
          } catch (_) {
            // ignore
          }
        }

        if (!normalizedChoices.length) {
          return fail(id, "Invalid vote: no choices provided");
        }

        const payload = {
          poll: String(pollId),
          action: "vote",
          choices: normalizedChoices,
        };

        const op = ['custom_json', {
          id: 'polls',
          json: JSON.stringify(payload),
          required_auths: [],
          required_posting_auths: [username],
        }];

        return performOperations(
          id,
          [op],
          "polls",
          username,
          postingKey,
          token,
          authKey,
        );
      } catch (error) {
        return fail(id, error);
      }
    }

    function followUser(
      id,
      username,
      author,
      follow,
      postingKey,
      token,
      authKey,
    ) {
      try {
        if (!username) {
          return fail(id, "Missing username");
        }
        if (!author) {
          return fail(id, "Missing author");
        }
        if (!postingKey) {
          return fail(id, "Missing postingKey");
        }

        const followString = typeof follow === "string" ? follow.toLowerCase() : follow;
        const shouldFollow = followString === true || followString === "true";
        const what = shouldFollow ? ["blog"] : [];
        const operationLabel = shouldFollow ? "follow" : "unfollow";

        const op = ['custom_json', {
          id: 'follow',
          required_auths: [],
          required_posting_auths: [username],
          json: JSON.stringify(['follow', { follower: username, following: author, what }]),
        }];

        return performOperations(
          id,
          [op],
          operationLabel,
          username,
          postingKey,
          token,
          authKey,
        );
      } catch (error) {
        return fail(id, error);
      }
    }

    function muteUser(
      id,
      username,
      author,
      mute,
      postingKey,
      token,
      authKey,
    ) {
      try {
        if (!username) {
          return fail(id, "Missing username");
        }
        if (!author) {
          return fail(id, "Missing author");
        }
        if (!postingKey) {
          return fail(id, "Missing postingKey");
        }

        const muteString = typeof mute === "string" ? mute.toLowerCase() : mute;
        const shouldMute = muteString === true || muteString === "true";
        const what = shouldMute ? ["ignore"] : [];
        const operationLabel = shouldMute ? "mute" : "unmute";

        const op = ['custom_json', {
          id: 'follow',
          required_auths: [],
          required_posting_auths: [username],
          json: JSON.stringify(['follow', { follower: username, following: author, what }]),
        }];

        return performOperations(
          id,
          [op],
          operationLabel,
          username,
          postingKey,
          token,
          authKey,
        );
      } catch (error) {
        return fail(id, error);
      }
    }

    function validatePostingKey(id, accountName, postingKey, accountJson) {
      try {
        const account = JSON.parse(accountJson);
        const postingKeyAuths =
          account &&
          account.posting &&
          Array.isArray(account.posting.key_auths)
            ? account.posting.key_auths
            : [];
        const activeKeyAuths =
          account &&
          account.active &&
          Array.isArray(account.active.key_auths)
            ? account.active.key_auths
            : [];
        const ownerKeyAuths =
          account &&
          account.owner &&
          Array.isArray(account.owner.key_auths)
            ? account.owner.key_auths
            : [];

        const postingPublicKeys = postingKeyAuths
          .map((auth) => (Array.isArray(auth) ? auth[0] : null))
          .filter(Boolean);
        const allPublicKeys = [
          ...postingPublicKeys,
          ...activeKeyAuths
            .map((auth) => (Array.isArray(auth) ? auth[0] : null))
            .filter(Boolean),
          ...ownerKeyAuths
            .map((auth) => (Array.isArray(auth) ? auth[0] : null))
            .filter(Boolean),
        ];

        try {
          const pKey = dhive.PrivateKey.fromString(postingKey)
            .createPublic()
            .toString();
          if (allPublicKeys.includes(pKey)) {
            return ok(id, "true");
          }
          return fail(id, "Invalid Key supplied");
        } catch (wifError) {
          const keyFromPassword = dhive.PrivateKey.fromLogin(
            accountName,
            postingKey,
            "posting",
          );
          const derivedPublic = keyFromPassword.createPublic().toString();
          if (postingPublicKeys.includes(derivedPublic)) {
            return ok(id, keyFromPassword.toString());
          }
          return fail(id, "Invalid Key supplied");
        }
      } catch (error) {
        return fail(id, error);
      }
    }

    function getImageUploadProofWithPostingKey(id, account, key) {
      try {
        const timestamp = Date.now() / 1000;
        const message = {
          signed_message: { type: "code", app: "ecency.app" },
          authors: [account],
          timestamp,
        };
        const stringified = JSON.stringify(message);
        const signature = hive.auth.signMessage(stringified, key);
        message.signatures = [signature];
        const result = b64uEnc(JSON.stringify(message));
        replyToNative(result, id, false);
        return result;
      } catch (error) {
        return fail(id, error);
      }
    }
  </script>
</body>

</html>
